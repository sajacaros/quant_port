# Chapter13 퀀트 전략을 이용한 종목 선정
* 포트폴리오 운용 전략
  * 과거 주식 시장을 분석해 좋은 주식의 기준을 찾아내어 매매
  * 투자의 속도가 느림
  * 다수의 종목을 하나의 포트폴리오로 구성해 운용
* 트레이딩 전략
  * 주식의 오르내림을 연구한 후 각종 지표를 이용해 매매
  * 투자의 속도가 빠름
  * 소수의 종목을 대상으로 함
## 13.1 팩터 이해하기
* 팩터란?
  * 주식의 수익률에 영향을 미치는 특성
  * 지속성
    * 오랜 기간, 여러 경제 상황에서도 꾸준히 작동해야 함
  * 범용성
    * 특정 국가 뿐만 아니라 다양한 국가, 지역, 섹터, 자산군에서도 작동해야 함
  * 이해 가능성
    * 전략이 작동하는 이유 및 지속 가능한지에 대한 설명이 가능해야 함
    * 이유가 없는 효과는 우연 또는 과최적화의 결과일 가능성이 높음
  * 강건성
    * 비슷한 팩터에서도 잘 동작해야 하며 결과 역시 비슷해야 함
  * 투자 가능성
    * 실제 투자가능해야 함(PTP 주의)
## 13.2 베타 이해하기
* 베타
  * 개별 주식이 전체 주식시장의 변동에 반응하는 정도를 나타낸 값
  * 통계학의 회귀분석모형에서 기울기를 나타냄
    * y = a + bx
* 자산가격결정모형(CAPM)
  * Capital Asset Pricing Model
  * 통계학의 회귀분석모형을 주식에 적용한 모형
  * ![CAPM](../image/factor/CAPM.PNG)
  * Rf : 무위험 수익률
  * Rm - Rf : 시장위험 프리미엄
  * Ri : 개별주식의 수익률
  * Bi : 개별주식의 베타
### 13.2.1 베타 계산하기
* ex) Rm - KOSPI 지수, Ri = 증권주
  * 일별 수익률 구하기
``` 
import pandas as pd
import yfinance as yf

tickers = ['^KS11', '039490.KS'] # KOSPI와 키움증권

all_data = {}
for ticker in tickers:
  all_data[ticker] = yf.download(ticker, start="2015-01-01")
prices = pd.DataFrame({tic: data['Close'] for tic, data in all_data.items()})
ret = prices.pct_change().dropna()
```
  * 베타 계산하기
``` 
# pip install statsmodels
import statsmodels.api as sm

# ret['intercept'] = 1
ret = sm.add_constant(ret)
reg = sm.OLS(ret[['039490.KS']], ret[['^KS11', 'const']]).fit()
reg.summary()
reg.params
```
  * 베타 - coef
  * t값이 절대값 2보다 크면 유의하다고 판단
  * 알파(intercept)는 coef와 t값이 낮음
  * 증권주의 수익률은 베타를 제외하고 나면 초과 수익이 없음
    * y = a + b*x = a*1 + b*x 
    * => 일반화 시키면 1도 하나의 변수로 보아, 수익률 = a*x1 + b*x2
## 13.3 밸류 전략
* 가치주 효과란?
  * 내재 가치 대비 낮은 가격의 주식이 내재 가치 대비 비싼 주식보다 수익률이 높은 현상
  * 저평가 <- 과민 반응
  * 고평가 <- 확증 편향
  * 결국 주가는 적정 가치를 찾아가면서 가치주 효과가 발생함
### 13.3.1 DataReader() 함수를 이용한 팩터 데이터 다운로드
* 파마-프렌치 3팩터
  * 케네스 프렌치 교수의 데이터 라이브러리
  * 각종 팩터에 관한 수익률이 매월 업데이트됨
  * [링크](https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html)
``` 
from pandas_datareader import data as pdr
from pandas_datareader.famafrench import get_available_datasets

dataserts = get_available_datasets()
dataserts[1:20]
```
### 13.3.2 PBR별 포트폴리오의 수익률
* PBR 수익률
  * Portfolios_Formed_on_BE-ME
``` 
from pandas_datareader import data as pdr
df_pbr = pdr.DataReader('Portfolios_Formed_on_BE-ME', 'famafrench', start='1900-01-01')
df_pbr[0].head()
```
* 5분위 수익률 차트
``` 
import matplotlib.pyplot as plt
from matplotlib import cm

plt.rc('font', family='Malgun Gothic')
plt.rc('axes', unicode_minus=False)

df_pbr_vw = df_pbr[0].loc[:, ['Lo 20', 'Qnt 2', 'Qnt 3', 'Qnt 4', 'Hi 20']]
df_pbr_cum = (1 + df_pbr_vw / 100).cumprod()
df_pbr_cum.plot(figsize=(10, 6),
                colormap=cm.jet,
                legend='reverse',
                title='PBR별 포트폴리오의 누적 수익률')
plt.show()
```
* 로그 차트로 구리기
``` 
import numpy as np

df_pbr_cum = np.log(1+df_pbr_vw/100).cumsum()
df_pbr_cum.plot(figsize=(10, 6),
                colormap=cm.jet,
                legend='reverse',
                title='PBR별 포트폴리오의 누적 수익률')
plt.show()
```
* 연율화 수익률(기하), 연율화 수익률(산술), 연율화 변동성, 샤프 지수를 구하는 함수
``` 
import pandas as pd

def factor_stat(df):

    n = len(df)

    ret_ari = (df / 100).mean(axis=0) * 12
    ret_geo = (1 + df / 100).prod()**(12 / n) - 1
    vol = (df / 100).std(axis=0) * np.sqrt(12)
    sharp = ret_ari / vol

    stat = pd.DataFrame(
        [ret_ari, ret_geo, vol, sharp],
        index=['연율화 수익률(산술)', '연율화 수익률(기하)', '연율화 변동성', '샤프지수']).round(4)

    stat.iloc[0:3, ] = stat.iloc[0:3, ] * 100

    return stat
```
* 활용
``` 
factor_stat(df_pbr_vw)
```
* PER 수익률
  * Portfolios_Formed_on_E-P
``` 
df_per = pdr.DataReader('Portfolios_Formed_on_E-P',
                        'famafrench',
                        start='1900-01-01')
df_per_vw = df_per[0].loc[:, ['Lo 20', 'Qnt 2', 'Qnt 3', 'Qnt 4', 'Hi 20']]
df_per_cum = np.log(1 + df_per_vw / 100).cumsum()
df_per_cum.plot(figsize=(10, 6),
                colormap=cm.jet,
                legend='reverse',
                title='PER별 포트폴리오의 누적 수익률')
plt.show()
```
* PCR 수익률
  * Portfolios_Formed_on_CF-P
``` 
df_pcr = pdr.DataReader('Portfolios_Formed_on_CF-P',
                        'famafrench',
                        start='1900-01-01')
df_pcr_vw = df_pcr[0].loc[:, ['Lo 20', 'Qnt 2', 'Qnt 3', 'Qnt 4', 'Hi 20']]
df_pcr_cum = np.log(1 + df_pcr_vw / 100).cumsum()
df_pcr_cum.plot(figsize=(10, 6),
                colormap=cm.jet,
                legend='reverse',
                title='PCR별 포트폴리오의 누적 수익률')
plt.show()
```
* PBR, PER, PCR 지표에서 가치주 효과가 나타나는 것 확인
### 13.3.3 밸류 포트폴리오 구하기
* 티커와 가치 지표
``` 
from sqlalchemy import create_engine
import pandas as pd
import numpy as np

engine = create_engine('mysql+pymysql://quantist:quant!*#@127.0.0.1:3306/stock_db')

ticker_list = pd.read_sql("""
select * from kor_ticker
where 기준일 = (select max(기준일) from kor_ticker) 
	and 종목구분 = '보통주';
""", con=engine)

value_list = pd.read_sql("""
select * from kor_value
where 기준일 = (select max(기준일) from kor_value);
""", con=engine)

engine.dispose()
```
* 조작하기 편하도록 데이터 수정
``` 
value_list.head()
value_list.info()
value_list.loc[value_list['값'] <= 0, '값'] = np.nan # 음수와 0은 nan으로 변경
value_pivot = value_list.pivot(index='종목코드', columns='지표', values='값')
data_bind = ticker_list[['종목코드', '종목명']].merge(value_pivot,
                                               how='left',
                                               on='종목코드')

data_bind.head()
```
* PER와 PBR이 낮은 종목 찾기
``` 
value_rank = data_bind[['PER', 'PBR']].rank(axis=0)
value_rank.head()
value_sum = value_rank.sum(axis=1, skipna=False).rank() # nan 종목은 제외
value_sum.head()
data_bind.loc[value_sum<=20, ['종목코드', '종목명', 'PER', 'PBR']]
```
### 13.3.4 여러 지표 결합하기
* 여러 지표간의 상관관계
``` 
import matplotlib.pyplot as plt
import seaborn as sns

value_list_copy = data_bind.copy()
value_list_copy['DY'] = 1 / value_list_copy['DY']
value_list_copy = value_list_copy[['PER', 'PBR', 'PCR', 'PSR', "DY"]]
value_rank_all = value_list_copy.rank(axis=0)
mask = np.triu(value_rank_all.corr())

mask = np.triu(value_rank_all.corr())
fig, ax = plt.subplots(figsize=(10, 6))
sns.heatmap(value_rank_all.corr(),
            annot=True,
            mask=mask,
            annot_kws={"size": 16},
            vmin=0,
            vmax=1,
            center=0.5,
            cmap='coolwarm',
            square=True)
ax.invert_yaxis()
plt.show()
```
* PER, PBR, PCR, PSR, DY를 통합한 가치주 구하기
``` 
value_sum_all = value_rank_all.sum(axis=1, skipna=False).rank()
data_bind.loc[value_sum_all <= 20]
```

## 13.4 모멘텀 전략
* 내재가치 변화에 따른 시장가격의 반응
![시장가격 반응](../image/factor/momentum.png)
### 13.4.1 모멘텀별 포트폴리오의 수익률
* 최근 12개월 수익률을 기준으로 구성된 포트폴리오의 수익률 비교
  * 10_Portfolios_Prior_12_2
``` 
import pandas_datareader.data as web
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm

df_mom = web.DataReader('10_Portfolios_Prior_12_2',
                        'famafrench',
                        start='1900-01-01')
df_mom_vw = df_mom[0]
df_mom_cum = np.log(1 + df_mom_vw / 100).cumsum()

plt.rc('font', family='Malgun Gothic')
plt.rc('axes', unicode_minus=False)

df_mom_cum.plot(figsize=(10, 6),
                colormap=cm.jet,
                legend='reverse',
                title='모멘텀별 포트폴리오의 누적 수익률')
plt.show()

factor_stat(df_mom_vw)
```
### 13.4.2 모멘텀 포트폴리오 구하기
* 국내 모멘텀 주식 구하기
* 1년치 가격정보 획득
``` 
from sqlalchemy import create_engine
import pandas as pd

engine = create_engine('mysql+pymysql://quantist:quant!*#@127.0.0.1:3306/stock_db')

ticker_list = pd.read_sql(
"""
select * from kor_ticker
where 기준일 = (select max(기준일) from kor_ticker) 
	and 종목구분 = '보통주';
""", con=engine)


price_list = pd.read_sql(
"""
select 날짜, 종가, 종목코드
from kor_price
where 날짜 >= (select (select max(날짜) from kor_price) - interval 1 year);
""", con=engine) # 최근 1년치 데이터

engine.dispose()

price_list.head()
```
* index - 날짜, column - 종목코드 형태로 변환
``` 
price_pivot = price_list.pivot(index='날짜', columns='종목코드', values='종가')
price_pivot.iloc[0:5, 0:5]
```
* 12개월 수익률 구하기
``` 
ret_list = pd.DataFrame( data=(price_pivot.iloc[-1] / price_pivot.iloc[0])-1, columns=['return'] )
data_bind = ticker_list[['종목코드', '종목명']].merge(ret_list, how='left', on='종목코드')
data_bind.head()
```
* 순위 구하기
``` 
momentum_rank = data_bind['return'].rank(axis=0, ascending=False)
data_bind[momentum_rank <= 20]
```
* 차트 그래프로 확인하기
``` 
price_momentum = price_list[price_list['종목코드'].isin(data_bind.loc[momentum_rank <= 20, '종목코드'])]
import matplotlib.pyplot as plt
import seaborn as sns

plt.rc('font', family='Malgun Gothic')
g = sns.relplot(data=price_momentum,
                x='날짜',
                y='종가',
                col='종목코드',
                col_wrap=5,
                kind='line',
                facet_kws={
                    'sharey': False,
                    'sharex': True
                })
g.set(xticklabels=[])
g.set(xlabel=None)
g.set(ylabel=None)
g.fig.set_figwidth(15)
g.fig.set_figheight(8)
plt.subplots_adjust(wspace=0.5, hspace=0.2)
plt.show()
```
### 13.4.3 K-Ratio
* 위 차트를 보면 아래와 같은 종목을 볼 수 있다.
  * 장기간 수익률이 횡보하다가 최근 주가가 급등하여 누적 수익률이 높게 나오는 종목
  * 몇 달전에 주가가 급등한 후 최근에는 하락세이지만, 누적 수익률이 높게 나오는 종목
* 좋은 모멘텀 주식이란?
  * 꾸준하게 상승하는 종목
* K-Ratio 지표
  * 모멘텀의 꾸준함을 측정하는 지표
  * ![K-Ratio](../image/factor/K-Ratio.PNG)
* 한 종목의 K-Ratio 구하기
``` 
import statsmodels.api as sm
import numpy as np

ret = price_pivot.pct_change().iloc[1:]
ret_cum = np.log(1+ret).cumsum()

x = np.array(range(len(ret)))
y = ret_cum.iloc[:, 0].values # 종목 1개 선정

reg = sm.OLS(y, x).fit()
reg.summary()

print(reg.params, reg.bse, (reg.params/reg.bse))
```
* 모든 종목의 K-Ratio 구하기
``` 
x = np.array(range(len(ret)))
k_ratio = {}

for i in range(0, len(ticker_list)):
  ticker = data_bind.loc[i, '종목코드']
  try:
    y = ret_cum.loc[:, price_pivot.columns == ticker]
    reg = sm.OLS(y, x).fit()
    res = float(reg.params / reg.bse)
  except:
    res = np.nan
  k_ratio[ticker] = res

k_ratio_bind = pd.DataFrame.from_dict(k_ratio, orient='index').reset_index()
k_ratio_bind.columns = ['종목코드', 'K-Ratio']

k_ratio_bind.head()
```
* K-Ratio 높은 종목 찾기
``` 
data_bind = data_bind.merge(k_ratio_bind, how='left', on='종목코드')
k_ratio_rank = data_bind['K-Ratio'].rank(axis=0, ascending=False)
data_bind[k_ratio_rank <= 20]
```
* 차트 그래프 확인
``` 
k_ratio_momentum = price_list[price_list['종목코드'].isin(data_bind.loc[k_ratio_rank <= 20, '종목코드'])]
plt.rc('font', family='Malgun Gothic')
g = sns.relplot(data=k_ratio_momentum,
                x='날짜',
                y='종가',
                col='종목코드',
                col_wrap=5,
                kind='line',
                facet_kws={
                    'sharey': False,
                    'sharex': True
                })
g.set(xticklabels=[])
g.set(xlabel=None)
g.set(ylabel=None)
g.fig.set_figwidth(15)
g.fig.set_figheight(8)
plt.subplots_adjust(wspace=0.5, hspace=0.2)
plt.show()
```

## 13.5 퀄리티 전략
* 우량성 지표
  * 수익성
    * 기업이 돈을 잘 버는가
    * ex) ROE, ROA, 매출총이익률
  * 수익의 안정성
    * 기업이 얼마나 안정적으로 돈을 버는가
    * ex) ROE 변동성
  * 재무 구조
    * 기업의 재무 구조가 얼마나 안전한가
    * ex) 차입 비율
  * 이익의 성장
    * 기업의 이익 증가율이 얼마나 되는가
    * ex) 전년 대비 ROE 증가율
  * 재무 신뢰도
    * 재무제표를 얼마나 신뢰할 수 있는가
    * ex) 회계 처리 방법
  * 배당
    * 얼마나 주주 친화적인가
    * 배당금, 신주 발행, 자사주 매입
  * 투자
    * 얼마나 신사업에 투자를 하는가
    * ex) 총자산의 증가
* 대표적인 수익성 지표
  * ROE
    * Return on Equity
    * 자기자본이익률
    * 당기순이익 / 자본
  * ROA
    * Return on Asset
    * 총자산이익률
    * 당기순이익 / 자산
  * ROIC
    * Return on Invested Capital
    * 투하자본이익률
    * 당기순이익 / 투하자본
  * GP
    * Gross Profitablility
    * 매출총이익률
    * 매출총이익 / 자산or자본
### 13.5.1 수익성별 포트폴리오의 수익률
* 영업수익성 포트폴리오의 수익률
  * Portfolios_Formed_on_OP
    * operating profits divided by book equity
  * https://github.com/pydata/pandas-datareader/issues/852
* 참고 pandas_datareader가 제공하는 데이터 밴더
  * https://pandas-datareader.readthedocs.io/en/latest/readers/index.html
``` 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm

url = 'https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/ftp/Portfolios_Formed_on_OP_CSV.zip'
df_op = pd.read_csv(url, skiprows=24, encoding='cp1252', index_col=0)
end_point = np.where(pd.isna(df_op.iloc[:, 2]))[0][0]
df_op_vw = df_op.iloc[0:end_point][[
    'Lo 20', 'Qnt 2', 'Qnt 3', 'Qnt 4', 'Hi 20'
]].apply(pd.to_numeric)
df_op_cum = np.log(1 + df_op_vw / 100).cumsum()

plt.rc('font', family='Malgun Gothic')
plt.rc('axes', unicode_minus=False)

df_op_cum.plot(figsize=(10, 6),
               colormap=cm.jet,
               legend='reverse',
               title='수익성별 포트폴리오의 누적 수익률')
plt.show()
```
* 통계값 확인
``` 
factor_stat(df_op_vw)
```
### 13.5.2 우량성 포트폴리오 구하기
* 국내 종목 확인
* 재무제표 데이터 확보
``` 
from sqlalchemy import create_engine
import pandas as pd
import numpy as np

engine = create_engine('mysql+pymysql://quantist:quant!*#@127.0.0.1:3306/stock_db')

ticker_list = pd.read_sql("""
select * from kor_ticker
where 기준일 = (select max(기준일) from kor_ticker) 
and 종목구분 = '보통주';
""", con=engine)

fs_list = pd.read_sql("""
select * from kor_fs
where 계정 in ('당기순이익', '매출총이익', '영업활동으로인한현금흐름', '자산', '자본')
and 공시구분 = 'q';
""", con=engine)

engine.dispose()
```
* 수익성 지표 계산
``` 
fs_list = fs_list.sort_values(['종목코드', '계정', '기준일'])
fs_list['ttm'] = fs_list.groupby(['종목코드', '계정'], as_index=False)['값'].rolling(
    window=4, min_periods=4).sum()['값']
fs_list_clean = fs_list.copy()
fs_list_clean['ttm'] = np.where(fs_list_clean['계정'].isin(['자산', '자본']),
                                fs_list_clean['ttm'] / 4, fs_list_clean['ttm'])
fs_list_clean = fs_list_clean.groupby(['종목코드', '계정']).tail(1)

fs_list_pivot = fs_list_clean.pivot(index='종목코드', columns='계정', values='ttm')
fs_list_pivot['ROE'] = fs_list_pivot['당기순이익'] / fs_list_pivot['자본']
fs_list_pivot['GPA'] = fs_list_pivot['매출총이익'] / fs_list_pivot['자산']
fs_list_pivot['CFO'] = fs_list_pivot['영업활동으로인한현금흐름'] / fs_list_pivot['자산']

quality_list = ticker_list[['종목코드', '종목명']].merge(fs_list_pivot,
                                                  how='left',
                                                  on='종목코드')
quality_list.round(4).head()
```
* 순위 구하기
``` 
quality_list_copy = quality_list[['ROE', 'GPA', 'CFO']].copy()
quality_rank = quality_list_copy.rank(ascending=False, axis=0)
```
* 상관관계 확인
``` 
import matplotlib.pyplot as plt
import seaborn as sns

mask = np.triu(quality_rank.corr())
fig, ax = plt.subplots(figsize=(10, 6))
sns.heatmap(quality_rank.corr(),
            annot=True,
            mask=mask,
            annot_kws={"size": 16},
            vmin=0,
            vmax=1,
            center=0.5,
            cmap='coolwarm',
            square=True)
ax.invert_yaxis()
plt.show()
```
* 종목 확인
``` 
quality_sum = quality_rank.sum(axis=1, skipna=False).rank()
quality_list.loc[quality_sum <= 20,
                 ['종목코드', '종목명', 'ROE', 'GPA', 'CFO']].round(4)
```

## 13.6 마법 공식
### 13.6.1 퀄리티와 밸류 간의 관계
### 13.6.2 마법 공식 이해하기
### 13.6.3 마법 공식 포트폴리오

## 13.7 섹터 중립 포트폴리오

## 13.8 이상치 데이터 처리 및 팩터의 결합
### 13.8.1 트림: 이상치 데이터 삭제
### 13.8.2 윈저라이징: 이상치 데이터 대체
### 13.8.3 팩터의 결합 방법

## 13.9 멀티팩터 포트폴리오